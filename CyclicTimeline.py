#!/usr/bin/env python3

from collections import namedtuple
from datetime import datetime, timedelta
from math import ceil

from dom import Document
from pysvgi import Svg, Line, Text

class DatetimeUtil:
    """Adds some additional methods to the standard datetime class"""
    
    # tuple as generated by datetime.timetuple:
    #
    # time.struct_time(
    #   tm_year=2017, 
    #   tm_mon=9, 
    #   tm_mday=17, 
    #   tm_hour=0, 
    #   tm_min=37, 
    #   tm_sec=30, 
    #   tm_wday=6, 
    #   tm_yday=260, 
    #   tm_isdst=-1)
    
    ResolutionData = namedtuple(
        'ResolutionData',
        ['mask', 'timedelta_args'])
    
    RESOLUTIONS = {
        'hour': ResolutionData(
            (1, 1, 1, 1, 0, 0, 0),
            {'seconds': 60 * 60})
    }
        

    @staticmethod
    def round_down(datetime_in, resolution):
        if resolution not in DatetimeUtil.RESOLUTIONS:
            raise ValueError("Invalid resolution %s" % resolution)
        mask = DatetimeUtil.RESOLUTIONS[resolution].mask
        dateTuple = datetime_in.timetuple()[:7]
        args = [a*b for a,b in zip(dateTuple, mask)]
        return datetime(*args)
         
    @staticmethod         
    def round_up(datetime_in, resolution):
        rounded_datetime = DatetimeUtil.round_down(datetime_in, resolution)
        timedelta_args = DatetimeUtil.RESOLUTIONS[resolution].timedelta_args
        return rounded_datetime + timedelta(**timedelta_args)
        
    
    
class CyclicTimeline(Svg): 
    
    CycleConfiguration = namedtuple(
        'CycleConfiguration',
        ['timedeltaArgs'])
    
    CYCLE_LENGTHS = {
        'hour': CycleConfiguration({'seconds':3600}),
        'day': CycleConfiguration({'days':1}),
        'week': CycleConfiguration({'days':7}),
        'year': CycleConfiguration({'days':365.25})
    }
    
    ROW_HEIGHT = 20
    
    def __init__(self, startDate, endDate, cycleLength='hour'):
        super().__init__()
        self.cycleLength = cycleLength
        
        self.startDate = DatetimeUtil.round_down(startDate, cycleLength)
        self.endDate = DatetimeUtil.round_up(endDate, cycleLength)        
        
        self.events = []
        

    def getRowCount(self, span):
        if self.cycleLength == 'hour':
            return ceil(span.total_seconds() / 60.0 / 60.0)
        raise ValueError('%s cycleLength not implemented' % self.cycleLength)

    
    def getRowStartTime(self, rowIndex):
        configuration = self.CYCLE_LENGTHS.get(self.cycleLength, None)
        if configuration is None:
            raise ValueError('%s cycleLength not implemented' % self.cycleLength)
        timedeltaArgs = configuration.timedeltaArgs
        timedeltaArgs = {k:v*rowIndex for k, v in timedeltaArgs.items()}
        return self.startDate + timedelta(**timedeltaArgs)
        

    def build(self):
        span = self.endDate - self.startDate
        print('timelineSpan', span)
        if self.cycleLength not in self.CYCLE_LENGTHS:
            raise ValueError("Unsupported cycleLength %s" % self.cycleLength)
        rows = self.getRowCount(span) 
        
        self.height = rows * self.ROW_HEIGHT
        self.width = 200

        for i in range(rows):
            rowStartTime = self.getRowStartTime(i)
            y = i * self.ROW_HEIGHT + self.ROW_HEIGHT / 2.0
            text = Text(str(rowStartTime))
            self.append(text)
            line = Line(0, y, self.width, y, stroke_width="1", stroke="black")
            self.append(line)
            
    
    def toprettyxml(self, indent='\t', newl='\n', encoding=''):
        self.build()
        return super().toprettyxml(indent, newl, encoding)
    
    def __str__(self):
        return super().__str__()
                                            
        

if __name__ == '__main__':
    timeline = CyclicTimeline(
        datetime(2017, 9, 10, 9),
        datetime(2017, 9, 10, 17),
        'hour')
    timeline.events = [datetime(2017, 9, 10, 9, 30)]
    
    with open('timeline.svg', 'w') as outFile:
        outFile.write(Document.XML_LINE + '\n')
        outFile.write(timeline.toprettyxml())
